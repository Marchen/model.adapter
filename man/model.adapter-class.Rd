% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model.adapter.r
\name{model.adapter-class}
\alias{model.adapter-class}
\alias{model.adapter}
\title{Abstraction layer for model functions/objects}
\description{
This class encapsulates differences in specifications of
statistical/machine learning functions and model objects to provide a
standardized way to access data and common methods of models.
To add support for a modeling function, new generator object of a
\code{\link{model.interface}} class must be implimented and methods that
cannot work well with the model should be overriden.
}
\section{Methods}{


	\strong{\code{model.adapter$new(x, envir = parent.frame(2L), data = NULL, package.name = NULL)}}

		Generate a new object.

		\subsection{Args}{
			\describe{
				\item{\code{x}}{
					an object of supported models or a call for a model
					function.
				}
				\item{\code{envir = parent.frame(2L)}}{
					an environment in which call in x is evaluated.
					Default value is the environment where the object of
					model.adapter was created.
				}
				\item{\code{data = NULL}}{
					a data.frame used for further manipulations.
				}
				\item{\code{package.name = NULL}}{
					a character specifying package name of the
					function/object. If not specified, package.name is
					automatically determined from \code{x}. This is mainly
					used to control functions with same name in different
					packages (e.g., \code{gam} in \code{gam} and
					\code{mgcv} packages).
				}
			}
		}

	\strong{\code{model.adapter$x.names(specials = NULL, type = c("all", "base"))}}

		Access names of explanatory variables.

		\subsection{Args}{
			\describe{
				\item{\code{specials = NULL}}{
					special characters to be passed to \link{terms}.
				}
				\item{\code{type = c("all", "base")}}{
					if "all", this function returns all explanatory variables
					including interactions, higher order terms, splines, etc.
					If "base" only basic form of the variables are returned.
				}
			}
		}

		\subsection{Returns}{
			a character vector of names of explanatory variables.
		}

	\strong{\code{model.adapter$y.names()}}

		Access names of response variables.

	\strong{\code{model.adapter$predict(newdata = NULL, type = c("response", "link", "prob", "class"), random = ~0, ...)}}

		Call predict method.

		For regression models, offset term is adjusted if 1) type is not "link",
		2) the model having only one offset term, 3) offset was specified as
		\code{offset = offset} or \code{formula = y ~ x + offset(offset)}
		rather than \code{offset = data$offset} or
		\code{formula = y ~ x + offset(data$offset)}, 4) the model is not
		\code{glmmML} or \code{ranger}.

		Also, it is users responsibility to use offset term with appropreate
		scale. For example if the model is \code{glm} with \code{poisson}
		family with \code{log} link function, the offset term should be
		\code{offset = log(offset)} or
		\code{formula = y ~ x + offset(log(offset))}.

		\subsection{Args}{
			\describe{
				\item{\code{newdata = NULL}}{
					a \code{data.frame} containing data used for
					prediction.
				}
				\item{
					\code{type = c("response", "link", "prob", "class")}
				}{
					the type of prediciton. "response" and "link" can be
					used for generalized linear (mixed) model and spcify
					scale of prediction.
					"response" is on the scale of the response variable.
					"link" is on the scale of the link function.
					"prob" and "class" are used for classification models.
					"prob" calculate probability of being each class of
					response variable.
					"class" makes predicted class for each observation.
				}
				\item{\code{random = ~0}}{
					the random effect to use.
					Tentatively, ~0 means don't use random effects.
				}
				\item{\code{...}}{
					other variables passed to predict methods.
				}
			}
		}

		\subsection{Returns}{
			a \code{
				\link[=model.adapter.prediction.class]{model.adapter.prediction}
			} object.
		}

	\strong{\code{model.adapter$residuals(type = c("response", "link"))}}

		Calculate residuals of the model.

		\subsection{Args}{
			\describe{
				\item{type = c("response", "link")}{
					a character specifying type of residual (i.e., scale of
					residual) to be calculated.
				}
			}
		}

		\subsection{Returns}{
			a numeric vector of residuals.
		}
}

\section{Details}{


	When calling \emph{model.adapter$new} using model call by
	\code{do.call}, please specify \emph{quote = TRUE}.
	Without it, a call of function in \emph{x} is evaluated and unintended
	result may be returned.
}

\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{call}}{a read-only \code{call} object used for initialization of
\code{model.adapter} or a \code{call} object which used for
construction of the model object.
Note that \code{call} in this field is modified to have their full
names by \code{match.call()} function.
Therefore, the \code{call} in this field doesn't need to be identical
to original \code{call} used for initialization of the class.
When the original \code{call} used for creating the model object could
not be recovered from the object, this field becomes \code{NULL}.}

\item{\code{object}}{a read-only object of the model.
If \code{model.adapter} is initialized by a \code{call} for a model
function, this field returns a object created by evaluating the
\code{call}.}

\item{\code{data}}{a read-only \code{data.frame} used for modeling.
At least, all columns used for the modeling are stored in this field.
Because some modeling function doesn't keep original \code{data.frame}
used for modeling or \code{call} in resultant object, this field can't
have the same \code{data.frame} used for modeling in such situation.
When all the columns used for the modeling is not available from this
field becomes \code{NULL}.
Also, when the model doesn't store original data and some function
such as `log()` was applied in model construction, the `data.frame`
stored in this field can be different from original values.
At least, this is applicable for `glmer` and `lmer`.}

\item{\code{formula}}{a read-only \code{formula} object specifying structure of the model.
'.' in the \code{formula} object is expanded so that this field may not
be same as the original \code{formula} specified in the \code{call} for
the model function or the model object in such case.}

\item{\code{family}}{a read-only character of family name.
If the model does not use family, this field is \code{NULL}.}

\item{\code{link}}{a function object of link function of the model. If the model does
not have link function, this field has \code{\link[base]{identity}}
function.}

\item{\code{linkinv}}{a function object of inverse link function of the model. If the model
does not have inverse link function, this field has
\code{\link[base]{identity}} function.}

\item{\code{package.name}}{a read-only character spcifying package name of the model.}

\item{\code{model.type}}{a character representing model type. The possible values are
"regression" and "classification".}

\item{\code{x.vars}}{a data.frame having all explanatory variables.}

\item{\code{y.vars}}{a data.frame having all response variables.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{model.adapter$new()}}
\item \href{#method-x.names}{\code{model.adapter$x.names()}}
\item \href{#method-y.names}{\code{model.adapter$y.names()}}
\item \href{#method-predict}{\code{model.adapter$predict()}}
\item \href{#method-residuals}{\code{model.adapter$residuals()}}
\item \href{#method-clone}{\code{model.adapter$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{model.adapter$new(
  x,
  envir = parent.frame(2L),
  data = NULL,
  package.name = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-x.names"></a>}}
\if{latex}{\out{\hypertarget{method-x.names}{}}}
\subsection{Method \code{x.names()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{model.adapter$x.names(specials = NULL, type = c("all", "base"))}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-y.names"></a>}}
\if{latex}{\out{\hypertarget{method-y.names}{}}}
\subsection{Method \code{y.names()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{model.adapter$y.names()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-predict"></a>}}
\if{latex}{\out{\hypertarget{method-predict}{}}}
\subsection{Method \code{predict()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{model.adapter$predict(
  newdata = NULL,
  type = c("response", "link", "prob", "class"),
  random = ~0,
  ...
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-residuals"></a>}}
\if{latex}{\out{\hypertarget{method-residuals}{}}}
\subsection{Method \code{residuals()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{model.adapter$residuals(type = c("response", "link"))}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{model.adapter$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
